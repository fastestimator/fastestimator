#!/usr/bin/env python
import argparse
import json
import os
import sys

from pyfiglet import Figlet

from fastestimator.util.util import parse_cli_to_dictionary, get_gpu_count
from fastestimator.visualization.layer_umap import umap_layers
from fastestimator.visualization.parse_logs import parse_folder
from fastestimator.visualization.saliency_masks import load_and_interpret


class SaveAction(argparse.Action):
    """
    A custom save action which is used to populate a secondary variable inside of an exclusive group. Used if this file
        is invoked directly during argument parsing.
    """

    def __init__(self, option_strings, dest, nargs='?', **kwargs):
        if '?' != nargs:
            raise ValueError("nargs must be \'?\'")
        super(SaveAction, self).__init__(option_strings, dest, nargs, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, True)
        setattr(namespace, self.dest + '_dir', values if values is None else os.path.join(values, ''))


def draw():
    print(Figlet(font="slant").renderText("FastEstimator"))


def logs(args, unknown):
    if len(unknown) > 0:
        print("error: unrecognized arguments: ", str.join(", ", unknown))
        sys.exit(-1)
    parse_folder(args['log_dir'], args['extension'], args['smooth'], args['save'], args['save_dir'], args['ignore'],
                 args['share_legend'], args['pretty_names'])


def configure_log_parser(subparsers):
    parser = subparsers.add_parser('logs',
                                   description='Generates comparison graphs amongst one or more log files',
                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('log_dir', metavar='<Log Dir>', type=str,
                        help="The path to a folder containing one or more log files")
    parser.add_argument('--extension', metavar='E', type=str,
                        help="The file type / extension of your logs",
                        default=".txt")
    parser.add_argument('--ignore', metavar='I', type=str, nargs='+',
                        help="The names of metrics to ignore though they may be present in the log files")
    parser.add_argument('--smooth', metavar='<float>', type=float,
                        help="The amount of gaussian smoothing to apply (zero for no smoothing)",
                        default=1)
    parser.add_argument('--pretty_names', help="Clean up the metric names for display",
                        action='store_true')

    legend_group = parser.add_argument_group('legend arguments')
    legend_x_group = legend_group.add_mutually_exclusive_group(required=False)
    legend_x_group.add_argument('--common_legend', dest='share_legend', help="Generate one legend total",
                                action='store_true', default=True)
    legend_x_group.add_argument('--split_legend', dest='share_legend', help="Generate one legend per graph",
                                action='store_false', default=False)

    save_group = parser.add_argument_group('output arguments')
    save_x_group = save_group.add_mutually_exclusive_group(required=False)
    save_x_group.add_argument('--save', nargs='?', metavar='<Save Dir>', dest='save', action=SaveAction,
                              default=False, help="Save the output image. May be accompanied by a directory into \
                                              which the file is saved. If no output directory is specified, the log \
                                              directory will be used")
    save_x_group.add_argument('--display', dest='save', action='store_false',
                              help="Render the image to the UI (rather than saving it)", default=True)
    save_x_group.set_defaults(save_dir=None)
    parser.set_defaults(func=logs)


def saliency(args, unknown):
    if len(unknown) > 0:
        print("error: unrecognized arguments: ", str.join(", ", unknown))
        sys.exit(-1)
    load_and_interpret(args['model'], args['inputs'], baseline=args['baseline'],
                       dictionary_path=args['dictionary'], strip_alpha=args['strip_alpha'],
                       smooth_factor=args['smooth'], save=args['save'], save_dir=args['save_dir'])


def configure_saliency_parser(subparsers):
    parser = subparsers.add_parser('saliency',
                                   description='Generates saliency maps for a model on given input(s)',
                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('model', metavar='<Model Path>', type=str,
                        help="The path to a saved model file")
    parser.add_argument('inputs', metavar='Input', type=str, nargs='+',
                        help="The paths to one or more inputs to visualize (or the path to a folder which will be \
                        recursively traversed to find image files)")
    parser.add_argument('--dictionary', metavar='<Dictionary Path>', type=str,
                        help="The path to a {'class_id':'class_name'} json file", default=None)
    parser.add_argument('--smooth', metavar='N', type=int, default=7,
                        help="The number of samples to use when generating smoothed saliency masks")
    parser.add_argument('--baseline', metavar='B', type=str, default='-1',
                        help="The value to use as a baseline for integrated gradient calculations. Can be either a \
                        number or the path to an image. What would a 'blank' input look like")
    parser.add_argument('--strip-alpha', action='store_true',
                        help="True if you want to convert RGBA images to RGB")
    save_group = parser.add_argument_group('output arguments')
    save_x_group = save_group.add_mutually_exclusive_group(required=False)
    save_x_group.add_argument('--save', nargs='?', metavar='<Save Dir>',
                              help="Save the output image. May be accompanied by a directory into which the \
                              file is saved. If no output directory is specified, the model directory will be used",
                              dest='save', action=SaveAction, default=False)
    save_x_group.add_argument('--display', dest='save', action='store_false',
                              help="Render the image to the UI (rather than saving it)", default=True)
    save_x_group.set_defaults(save_dir=None)
    parser.set_defaults(func=saliency)


def umap(args, unknown):
    hyperparameters = parse_cli_to_dictionary(unknown)
    umap_layers(args['model'], args['input_dir'], print_layers=args['print_layers'], strip_alpha=args['strip_alpha'],
                layers=args['layers'], batch=args['batch'], use_cache=args['cache'], cache_dir=args['cache_dir'],
                dictionary_path=args['dictionary'], legend_mode=args['legend'], save=args['save'],
                save_dir=args['save_dir'], umap_parameters=hyperparameters, input_extension=args['extension'])


def configure_umap_parser(subparsers):
    parser = subparsers.add_parser('umap',
                                   description='Plots umaps for model layers over given inputs',
                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('model', metavar='<Model Path>', type=str,
                        help="The path to a saved model file")
    parser.add_argument('input_dir', metavar='Input', type=str,
                        help="The path to a folder of folders containing inputs sorted by class")
    parser.add_argument('--print-layers', action='store_true',
                        help="True if you only want to print a model's layers to the console. Useful for inspecting a \
                            model to choose which layer indices to visualize.")
    parser.add_argument('--layers', metavar='IDX', type=int, nargs='+',
                        help='The indices of layers you want to visualize. If not provided then all layers will be \
                                      analyzed, but that is likely to run out of memory on moderately sized models.')
    parser.add_argument('--strip-alpha', action='store_true',
                        help="True if you want to convert RGBA images to RGB")
    parser.add_argument('--extension', metavar='E', type=str,
                        help="The file type / extension of your input files (default matches all files)",
                        default=None)
    parser.add_argument('--batch', type=int, default=50,
                        help="How many images to process at a time (set based on available RAM)")
    parser.add_argument('--dictionary', metavar='<Dictionary Path>', type=str,
                        help="The path to a {'class_id':'class_name'} json file", default=None)
    parser.add_argument('--legend', choices=['on', 'off', 'shared'], default='shared',
                        help='Whether to display legends or not.')
    save_group = parser.add_argument_group('output arguments')
    save_group.add_argument('--cache', metavar='<Cache Dir>', action=SaveAction, default=False,
                            help="Enable caching of intermediate results. Highly recommended to reduce RAM \
                            requirements. If no cache directory is specified, a sibling of the input directory will be \
                            used")
    save_group.set_defaults(cache_dir=None)
    save_x_group = save_group.add_mutually_exclusive_group(required=False)
    save_x_group.add_argument('--save', nargs='?', metavar='<Save Dir>', dest='save', action=SaveAction,
                              default=False, help="Save the output image. May be accompanied by a directory into \
                                                      which the file is saved. If no output directory is specified, \
                                                      the model directory will be used")
    save_x_group.add_argument('--display', dest='save', action='store_false',
                              help="Render the image to the UI (rather than saving it)", default=True)
    save_x_group.set_defaults(save_dir=None)
    parser.add_argument_group('umap arguments', 'Arguments from the umap module may all be passed through. Examples \
    include --n_neighbors <int>, --metric <str>, --n_epochs <int>, --min_dist <float>, --learning_rate <float>, etc...')
    parser.set_defaults(func=umap)


def configure_visualization_parser(subparsers):
    visualization_parser = subparsers.add_parser('visualize', description='Generates various types of visualiztaions')
    visualization_subparsers = visualization_parser.add_subparsers()
    # In python 3.7 the following 2 lines could be put into the .add_subparsers() call
    visualization_subparsers.required = True
    visualization_subparsers.dest = 'mode'

    configure_log_parser(visualization_subparsers)
    configure_saliency_parser(visualization_subparsers)
    configure_umap_parser(visualization_subparsers)


def train(args, unknown):
    num_process = args['num_process']
    entry_point = args['entry_point']
    inputs_path = args['inputs']

    hyperparameters = {}
    if args['hyperparameters_json']:
        hyperparameters = os.path.abspath(args['hyperparameters_json'])
        hyperparameters = json.load(open(hyperparameters, 'r'))

    hyperparameters.update(parse_cli_to_dictionary(unknown))

    module_name = os.path.splitext(os.path.basename(entry_point))[0]
    dir_name = os.path.abspath(os.path.dirname(entry_point))
    sys.path.insert(0, dir_name)
    spec_module = __import__(module_name, globals(), locals(), ["get_estimator"])
    estimator = spec_module.get_estimator(**hyperparameters)
    estimator.num_process = num_process

    # Wait until now to spawn multiple threads so that all of the inputs are validated to be correct.
    # That way the user won't get four different copies of the same error message if they enter something wrong
    if num_process > 1 and not args['worker']:
        cmd = "mpirun -np %d -H localhost:%d --allow-run-as-root " % (num_process, num_process) + \
              "fastestimator --worker " + str.join(" ", sys.argv[1:])
        os.system(cmd)
    else:
        estimator.fit(inputs=inputs_path)


def configure_train_parser(subparsers):
    parser = subparsers.add_parser('train', description='Train a FastEstimator model',
                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    # use an argument group for required flag arguments since otherwise they will show up as optional in the help
    parser.add_argument('entry_point', type=str, help='The path to the model python file')
    parser.add_argument('--num_process', type=int, help='The number of parallel training processes',
                        default=max(1, get_gpu_count()))
    parser.add_argument('--inputs', type=str, help='The path where tfrecord is saved or will be saved')
    parser.add_argument('--hyperparameters', dest='hyperparameters_json', type=str,
                        help="The path to the hyperparameters JSON file")
    parser.add_argument_group('hyperparameter arguments', 'Arguments to be passed through to the get_estimator() call. \
        Examples might look like --epochs <int>, --batch_size <int>, --optimizer <str>, etc...')
    parser.set_defaults(func=train)


def predict(args, unknown):
    if len(unknown) > 0:
        print("error: unrecognized arguments: ", str.join(", ", unknown))
        sys.exit(-1)
    print("Prediction not yet supported, but coming soon...!")


def configure_predict_parser(subparsers):
    parser = subparsers.add_parser('predict', description='Evaluate a trained model on new inputs')
    parser.set_defaults(func=predict)


def run():
    parser = argparse.ArgumentParser()
    parser.add_argument('--worker', action='store_true',
                        help='A flag used internally to manage multi-processing. It can be ignored by users.')
    subparsers = parser.add_subparsers()
    # In python 3.7 the following 2 lines could be put into the .add_subparsers() call
    subparsers.required = True
    subparsers.dest = 'mode'

    configure_train_parser(subparsers)
    configure_predict_parser(subparsers)
    configure_visualization_parser(subparsers)

    args, unknown = parser.parse_known_args()
    if not args.worker:
        draw()
    args.func(vars(args), unknown)


if __name__ == '__main__':
    run()
